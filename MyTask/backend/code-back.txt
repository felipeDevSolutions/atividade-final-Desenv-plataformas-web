BACKEND:

ðŸ“¦backend
 â”£ ðŸ“‚node_modules
 â”£ ðŸ“‚src
 â”ƒ â”£ ðŸ“‚controllers
 â”ƒ â”ƒ â”£ ðŸ“œtaskController.js
 â”ƒ â”ƒ â”— ðŸ“œUserController.js
 â”ƒ â”£ ðŸ“‚middleware
 â”ƒ â”ƒ â”— ðŸ“œauthMiddleware.js
 â”ƒ â”£ ðŸ“‚models
 â”ƒ â”ƒ â”£ ðŸ“œTask.js
 â”ƒ â”ƒ â”— ðŸ“œuser.js
 â”ƒ â”£ ðŸ“‚routes
 â”ƒ â”ƒ â”£ ðŸ“œauthRoutes.js
 â”ƒ â”ƒ â”£ ðŸ“œtaskRoutes.js
 â”ƒ â”ƒ â”— ðŸ“œuserRoutes.js
 â”ƒ â”£ ðŸ“‚tests
 â”ƒ â”ƒ â”— ðŸ“œuser.test.js
 â”ƒ â”£ ðŸ“œapp.js
 â”ƒ â”— ðŸ“œvercel.json
 â”£ ðŸ“œ.env
 â”£ ðŸ“œ.gitignore
 â”£ ðŸ“œcode-back.txt
 â”£ ðŸ“œfirebase-service-account.json
 â”£ ðŸ“œfirebaseConfig.js
 â”£ ðŸ“œpackage-lock.json
 â”— ðŸ“œpackage.json


app.js:
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const { db, auth, admin } = require('../firebaseConfig');
const jwt = require('jsonwebtoken');
const bcryptjs = require('bcryptjs');
const userRouter = require('./routes/userRoutes');
const authRouter = require('./routes/authRoutes');
const taskRoutes = require('./routes/taskRoutes');

dotenv.config();

const app = express();
const port = process.env.PORT;

// Middleware para habilitar CORS
app.use(cors());
app.use(express.json());

// Middleware para verificar o token JWT
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (token == null) {
    return res.status(401).json({ message: 'Token de autenticaÃ§Ã£o ausente' });
  }

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ message: 'Token invÃ¡lido' });
    }
    req.user = user;
    next();
  });
};

// Rotas
app.use('/api/users', authenticateToken, userRouter);
app.use('/api', authRouter);
app.use('/api/tasks', taskRoutes);

// Iniciar o servidor
app.listen(port, () => {
  console.log(`Servidor rodando em http://localhost:${port}`);
});

module.exports = app;


================================================================================================


.env:
PORT=5000
AUTHORIZATION_CODE=felipeDev
JWT_SECRET=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlN2QzZGE4LTQ0MzgtNDJhOC1iY2Y4LWI5YzM4ODRhYjYxYSIsImlhdCI6MTY0OTM4MTMwMSwiZXhwIjoxNjQ5Mzg0OTAxfQ.d9eTxzfo44oH8HrAZ0Yx8SjWWUNlIhj-74L4cENoLxI
EMAIL_USER=felipeedev2024@gmail.com
EMAIL_PASS=jsqbcpropjhfhacy



==================================================================================================


firebaseConfig.js:
const admin = require('firebase-admin');
const serviceAccount = require('./firebase-service-account.json');

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  databaseURL: 'https://app-fiz.firebaseio.com',
});

const db = admin.firestore();
const auth = admin.auth();

module.exports = { admin, db, auth };


==================================================================================================


authMiddleware.js:
const jwt = require('jsonwebtoken');

const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (token == null) {
    return res.status(401).json({ message: 'Token de autenticaÃ§Ã£o ausente' });
  }

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ message: 'Token invÃ¡lido' });
    }
    req.user = user; 
    next();
  });
};

module.exports = authenticateToken;



==================================================================================================


user.js:
const { db } = require('../../firebaseConfig');

class User {
  static async create(email, password, uid) {
    const userDocRef = db.collection('users').doc();
    await userDocRef.set({
      id: userDocRef.id,
      email,
      password,
      uid,
    });
    return userDocRef.id; // Retorna o ID do novo usuÃ¡rio
  }

  static async findById(userId) {
    const userDoc = await db.collection('users').doc(userId).get();
    if (userDoc.exists) {
      return userDoc.data();
    }
    return null;
  }

  static async updatePassword(userId, newPassword) {
    await db.collection('users').doc(userId).update({ password: newPassword });
  }

  static async delete(userId) {
    await db.collection('users').doc(userId).delete();
  }
}

module.exports = User;



===================================================================================================


UserController.js:
const User = require('../models/user');
const bcryptjs = require('bcryptjs');
const { auth, db } = require('../../firebaseConfig'); 
const jwt = require('jsonwebtoken');

class UserController {
  static async signup(req, res) {
    const { email, password } = req.body;

    try {
      // Verifica se o email jÃ¡ existe
      const userExists = await db.collection('users').where('email', '==', email).get();
      if (!userExists.empty) {
        return res.status(409).json({ message: 'Email jÃ¡ cadastrado' });
      }

      // Hash da senha
      const hashedPassword = await bcryptjs.hash(password, 10);

      // Criar usuÃ¡rio no Firebase
      const userRecord = await auth.createUser({
        email,
        password: hashedPassword,
      });

      const userId = userRecord.uid; 

      // Criar usuÃ¡rio no Firestore
      const newUserId = await User.create(email, hashedPassword, userId);

      res.status(201).json({ message: 'UsuÃ¡rio cadastrado com sucesso!', id: newUserId });

    } catch (error) {
      console.error('Erro ao cadastrar usuÃ¡rio: ', error);
      res.status(500).json({ message: 'Erro ao cadastrar usuÃ¡rio' });
    }
  }

  static async login(req, res) {
    const { email, password } = req.body;
  
    try {
      // Verificar se o usuÃ¡rio existe
      const userDoc = await db.collection('users').where('email', '==', email).get();
      if (userDoc.empty) {
        return res.status(400).json({ message: 'Credenciais invÃ¡lidas' });
      }
  
      const user = userDoc.docs[0].data(); // Obter o primeiro documento
      const userId = user.id; // Obter o ID do usuÃ¡rio do Firestore
  
      // Comparar senha
      const isValidPassword = await bcryptjs.compare(password, user.password);
      if (!isValidPassword) {
        return res.status(400).json({ message: 'Credenciais invÃ¡lidas' });
      }
  
      // Cria token JWT (definindo um tempo de expiraÃ§Ã£o - exemplo: 1 hora)
      const token = jwt.sign({ id: userId, email: user.email, uid: user.uid }, process.env.JWT_SECRET, { expiresIn: '1h' });
  
      res.status(200).json({ token, user });
  
    } catch (error) {
      console.error('Erro ao realizar login: ', error);
      res.status(500).json({ message: 'Erro ao realizar login' });
    }
  }

  static async getUsers(req, res) { 
    try {
      const users = [];
      const usersSnapshot = await db.collection('users').get();
      usersSnapshot.forEach((doc) => {
        users.push({ id: doc.id, ...doc.data() });
      });
      res.status(200).json(users);
  
    } catch (error) {
      console.error('Erro ao listar usuÃ¡rios: ', error);
      res.status(500).json({ message: 'Erro ao listar usuÃ¡rios' });
    }
  }

  static async updatePassword(req, res) {
    const userId = req.params.userId;
    const { oldPassword, newPassword, confirmPassword } = req.body;

    try {
      // Verificar se a senha antiga estÃ¡ correta
      const user = await User.findById(userId);
      if (!user) {
        return res.status(404).json({ message: 'UsuÃ¡rio nÃ£o encontrado' });
      }

      const isValidOldPassword = await bcryptjs.compare(oldPassword, user.password); 
      if (!isValidOldPassword) {
        return res.status(400).json({ message: 'Senha antiga invÃ¡lida' });
      }

      // Verificar se as novas senhas coincidem
      if (newPassword !== confirmPassword) {
        return res.status(400).json({ message: 'As novas senhas nÃ£o coincidem' });
      }

      // Hash da nova senha
      const hashedNewPassword = await bcryptjs.hash(newPassword, 10);

      // Atualizar senha no Firestore
      await User.updatePassword(userId, hashedNewPassword);

      res.status(200).json({ message: 'Senha atualizada com sucesso!' });

    } catch (error) {
      console.error('Erro ao atualizar senha: ', error);
      res.status(500).json({ message: 'Erro ao atualizar senha' });
    }
  }

  static async deleteUser(req, res) {
    const userId = req.params.userId;

    try {
      console.log('Excluindo usuÃ¡rio com ID:', userId);

      // Obter o uid do usuÃ¡rio do Firestore antes de deletar
      const user = await User.findById(userId);
      if (!user) {
        return res.status(404).json({ message: 'UsuÃ¡rio nÃ£o encontrado' });
      }
      const uid = user.uid;

      // Deletar usuÃ¡rio do Firebase Auth
      await auth.deleteUser(uid);
      console.log('UsuÃ¡rio excluÃ­do do Firebase Auth!');

      // Deletar usuÃ¡rio do Firestore
      await User.delete(userId);
      console.log('UsuÃ¡rio excluÃ­do do Firestore!');

      console.log('UsuÃ¡rio excluÃ­do com sucesso!');
      res.status(200).json({ message: 'UsuÃ¡rio excluÃ­do com sucesso!' });

    } catch (error) {
      console.error('Erro ao excluir usuÃ¡rio: ', error);
      res.status(500).json({ message: 'Erro ao excluir usuÃ¡rio' });
    }
  }
}

module.exports = UserController;


===================================================================================================


userRoutes.js:
const express = require('express');
const router = express.Router();
const authenticateToken = require('../middleware/authMiddleware'); 
const UserController = require('../controllers/UserController');

// Listar usuÃ¡rios (Protegida por autenticaÃ§Ã£o)
router.get('/', authenticateToken, UserController.getUsers);

// Atualizar senha de um usuÃ¡rio 
router.put('/:userId/password', authenticateToken, UserController.updatePassword);

// Excluir usuÃ¡rio (Protegida por autenticaÃ§Ã£o)
router.delete('/:userId', authenticateToken, UserController.deleteUser);

module.exports = router;



=======================================================================================================


authRoutes.js:
const express = require('express');
const router = express.Router();
const { db } = require('../../firebaseConfig');
const admin = require('firebase-admin');
const jwt = require('jsonwebtoken');
const bcryptjs = require('bcryptjs');
const UserController = require('../controllers/UserController');
const nodemailer = require('nodemailer');

// Cadastro de usuÃ¡rio
router.post('/signup', UserController.signup);

// Login de usuÃ¡rio
router.post('/login', UserController.login);

// ValidaÃ§Ã£o de Token (usada pelo AuthContext.js)
router.get('/validate', async (req, res) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (token == null) {
    return res.status(401).json({ message: 'Token de autenticaÃ§Ã£o ausente' });
  }

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ message: 'Token invÃ¡lido' });
    }

    // Retorna os dados do usuÃ¡rio
    res.status(200).json({ user });
  });
});

// Rota para renovar o token
router.post('/refreshToken', async (req, res) => {
  const { token } = req.body; 

  try {
    // Valide o token atual e gere um novo token
    const newToken = await admin.auth().createCustomToken(req.user.uid, {
      validSince: new Date(),
      validUntil: new Date(new Date().getTime() + 1000 * 60 * 60 * 24 * 7) // Validade de 7 dias, por exemplo
    });

    res.status(200).json({ token: newToken, expirationTime: new Date(new Date().getTime() + 1000 * 60 * 60 * 24 * 7).getTime() });
  } catch (error) {
    console.error('Erro ao atualizar token:', error);
    res.status(500).json({ message: 'Erro ao atualizar token' });
  }
});

// RecuperaÃ§Ã£o de senha
router.post('/forgot-password', async (req, res) => {
  const { email } = req.body;

  try {
    // Gera um link de redefiniÃ§Ã£o de senha
    const resetLink = await admin.auth().generatePasswordResetLink(email);

    // Configurar o serviÃ§o de email (usando nodemailer)
    let transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS
      }
    });

    let mailOptions = {
      from: process.env.EMAIL_USER,
      to: email,
      subject: 'RedefiniÃ§Ã£o de Senha',
      text: `Clique no link a seguir para redefinir sua senha: ${resetLink}`
    };

    // Envia o email com o link de redefiniÃ§Ã£o de senha
    await transporter.sendMail(mailOptions);

    res.status(200).json({ message: 'Email de redefiniÃ§Ã£o de senha enviado com sucesso!' });

  } catch (error) {
    console.error('Erro ao enviar email de redefiniÃ§Ã£o de senha:', error);

    // Verifica se o erro Ã© relacionado Ã  autenticaÃ§Ã£o do Firebase
    if (error.code === 'auth/user-not-found') {
      return res.status(404).json({ message: 'UsuÃ¡rio nÃ£o encontrado' });
    } else if (error.code === 'auth/invalid-email') {
      return res.status(400).json({ message: 'Email invÃ¡lido' });
    }

    // Outros erros
    res.status(500).json({ message: 'Erro ao enviar email de redefiniÃ§Ã£o de senha' });
  }
});

module.exports = router;



====================================================================================================


Task.js:
const { db, admin } = require('../../firebaseConfig');

const Task = {
  // Cria uma nova tarefa
  async create(userId, taskData) {
    try {
      const docRef = await db.collection('users').doc(userId).collection('tasks').add({
        task: taskData.task,
        completed: false,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      // Recupera a tarefa criada com o timestamp
      const taskDoc = await docRef.get();
      const task = {
        id: taskDoc.id,
        ...taskData,
        completed: false,
        createdAt: taskDoc.data().createdAt.toDate(), 
      };

      return task; 
    } catch (error) {
      console.error('Erro ao criar tarefa:', error);
      throw error;
    }
  },

  // Recupera todas as tarefas de um usuÃ¡rio
  async getByUser(userId) {
    try {
      const tasksRef = db.collection('users').doc(userId).collection('tasks');
      const tasksSnapshot = await tasksRef.get();
      const tasks = [];

      tasksSnapshot.forEach(doc => {
        const task = {
          id: doc.id,
          ...doc.data(),
          createdAt: doc.data().createdAt.toDate(), // Converte o timestamp do Firestore para Date
        };
        tasks.push(task);
      });

      return tasks;
    } catch (error) {
      console.error('Erro ao recuperar tarefas:', error);
      throw error;
    }
  },

  // Exclui uma tarefa
  async delete(userId, taskId) {
    try {
      await db.collection('users').doc(userId).collection('tasks').doc(taskId).delete();
      return true;
    } catch (error) {
      console.error('Erro ao excluir tarefa:', error);
      throw error;
    }
  }
};

module.exports = Task;


==================================================================================================


taskController.js:
const Task = require('../models/Task');
const authenticateToken = require('../middleware/authMiddleware');
const { db } = require('../../firebaseConfig');

const taskController = {
  // Cria uma nova tarefa
  async create(req, res) {
    try {
      const { task } = req.body;
      const newTask = await Task.create(req.user.id, { task });
      res.status(201).json(newTask);
    } catch (error) {
      res.status(500).json({ message: 'Erro ao criar tarefa.' });
    }
  },

  // Recupera todas as tarefas do usuÃ¡rio
  async getTasks(req, res) {
    try {
      const tasks = await Task.getByUser(req.user.id);
      res.status(200).json(tasks);
    } catch (error) {
      res.status(500).json({ message: 'Erro ao recuperar tarefas.' });
    }
  },

  // Exclui uma tarefa
  async deleteTask(req, res) {
    try {
      const taskId = req.params.taskId;
      await Task.delete(req.user.id, taskId);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: 'Erro ao excluir tarefa.' });
    }
  },

  // Marca uma tarefa como concluÃ­da ou nÃ£o concluÃ­da
  async toggleComplete(req, res) {
    try {
      const taskId = req.params.taskId;
      const taskRef = db.collection('users').doc(req.user.id).collection('tasks').doc(taskId);

      // Obtenha o status atual da tarefa
      const currentTask = await taskRef.get();

      // Verifica se a tarefa existe
      if (currentTask.exists) {
        const currentCompleted = currentTask.data().completed; // Obter o valor atual de completed

        // Atualiza o status da tarefa com o valor inverso
        await taskRef.update({ completed: !currentCompleted }); 
        res.status(204).send();
      } else {
        res.status(404).json({ message: 'Tarefa nÃ£o encontrada.' }); 
      }
    } catch (error) {
      res.status(500).json({ message: 'Erro ao atualizar tarefa.' });
    }
  }
};

module.exports = taskController;



=======================================================================================================


taskRoutes.js:
const express = require('express');
const router = express.Router();
const taskController = require('../controllers/taskController');
const authenticateToken = require('../middleware/authMiddleware');

// Cria uma nova tarefa
router.post('/', authenticateToken, taskController.create);

// Recupera todas as tarefas do usuÃ¡rio
router.get('/', authenticateToken, taskController.getTasks);

// Marca uma tarefa como concluÃ­da ou nÃ£o concluÃ­da
router.put('/:taskId/complete', authenticateToken, taskController.toggleComplete);

// Exclui uma tarefa
router.delete('/:taskId', authenticateToken, taskController.deleteTask);

module.exports = router;


==============================================================================================================


user.test.js:
const User = require('../models/user');
const UserController = require('../controllers/UserController');
const { auth, db } = require('../../firebaseConfig');
const bcrypt = require('bcryptjs');

describe('User', () => {
  let testUser;

  beforeEach(async () => {
    // Cria um usuÃ¡rio de teste antes de cada teste.
    const email = `testuser_${Math.random()}@example.com`; // Gerando um endereÃ§o de e-mail Ãºnico
    const password = 'password123';
    testUser = await User.create(email, password);
  });

  afterEach(async () => {
    // Limpa o usuÃ¡rio de teste apÃ³s cada teste.
    if (testUser) {
      await User.delete(testUser.id);
    }
  });

  it('deve criar um novo usuÃ¡rio', async () => {
    expect(testUser).toBeDefined();
    expect(testUser.id).toBeDefined();
    expect(testUser.email).toContain('testuser'); // Verificando se o email contÃ©m "testuser"
  });

  it('deve buscar um usuÃ¡rio por ID', async () => {
    const foundUser = await User.findById(testUser.id);
    expect(foundUser).toBeDefined();
    expect(foundUser.id).toEqual(testUser.id);
    expect(foundUser.email).toEqual(testUser.email);
  });

  it('deve buscar um usuÃ¡rio por email', async () => {
    const foundUser = await User.findByEmail(testUser.email);
    expect(foundUser).toBeDefined();
    expect(foundUser.id).toEqual(testUser.id);
    expect(foundUser.email).toEqual(testUser.email);
  });

  it('deve buscar todos os usuÃ¡rios', async () => {
    // Cria outro usuÃ¡rio para testar a busca de todos os usuÃ¡rios.
    const email = `anotheruser_${Math.random()}@example.com`; // Gerando um endereÃ§o de e-mail Ãºnico
    const anotherUser = await User.create(email, 'anotherpassword');

    const allUsers = await User.findAll();
    expect(allUsers).toBeDefined();
    expect(allUsers.length).toBeGreaterThanOrEqual(2); 
  });

  it('deve atualizar a senha de um usuÃ¡rio', async () => {
    const req = {
      body: {
        email: testUser.email, // Modificar para usar o email do usuÃ¡rio criado no beforeEach
        oldPassword: 'password123', // Senha antiga do usuÃ¡rio de teste
        newPassword: 'newPassword123' // Nova senha
      }
    };
    const res = {
      json: jest.fn(),
      status: jest.fn()
    };

    // Mock da funÃ§Ã£o UserController.updatePassword
    jest.spyOn(UserController, 'updatePassword').mockImplementationOnce(() => {
      // Chama a funÃ§Ã£o res.json dentro da implementaÃ§Ã£o do mock
      res.json({ message: 'Senha atualizada com sucesso' }); 
      return Promise.resolve(); // Retorne uma Promise resolvida para evitar erros
    });

    await UserController.updatePassword(req, res);

    // Verifique se a funÃ§Ã£o res.json() foi chamada com a mensagem correta
    expect(res.json).toHaveBeenCalledWith({ message: 'Senha atualizada com sucesso' });

    // Limpe o mock depois do teste
    jest.clearAllMocks(); // Use jest.clearAllMocks() para limpar os mocks
  });


  it('deve deletar um usuÃ¡rio', async () => {
    await User.delete(testUser.id);

    // Verifica se o usuÃ¡rio foi deletado do Firestore
    const userDoc = await db.collection('users').doc(testUser.id).get();
    expect(userDoc.exists).toBeFalsy();

    // Verifica se o usuÃ¡rio foi deletado do Firebase Auth
    try {
      await auth.getUser(testUser.id);
    } catch (error) {
      expect(error.code).toEqual('auth/user-not-found');
    }
  });

  it('deve comparar senhas corretamente', async () => {
    const passwordHash = await bcrypt.hash('password123', 10);
    const isMatch = await User.comparePassword('password123', passwordHash);
    expect(isMatch).toBeTruthy();

    const isNotMatch = await User.comparePassword('wrongpassword', passwordHash);
    expect(isNotMatch).toBeFalsy();
  });
});


